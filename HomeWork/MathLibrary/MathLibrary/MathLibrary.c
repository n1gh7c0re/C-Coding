#include "pch.h"
#include "MathLibrary.h"
#include <limits.h>

//простые вставки с поиском слева направо
void LeftInsertion(int A[], int n) {
	int i, j, x;
	/*перебирает массив, начиная с 1 - го элемента(идёт вправо),
	то есть такой способ делит массив на 2 части - отсортированную (слева) и неотсортированную (справа)*/
	for (i = 0; i < n; i++) {
		x = A[i]; //1-й элемент (извлеченный)
		j = i;
		/*далее идёт по массиву и сравнивает элемент с другими элементами из отсортированной части,
		то есть ищет нужное место для этого извлеченного элемента*/
		while ((j > 0) && (x < A[j - 1])) {
			A[j] = A[j - 1];
			j--;
		}
		A[j] = x; //присваивает элементу массива подходящее значение
	}
}

//простые вставки с поиском справа налево
void RightInsertion(int A[], int n) {
	int i, j, x;
	/*перебирает массив, начиная с последнего элемента(идёт влево),
	то есть такой способ делит массив на 2 части - отсортированную (справа) и неотсортированную (слева)*/
	for (i = n - 2; i >= 0; i--) {
		x = A[i]; //предпоследний элемент (извлеченный)
		j = i;
		/*далее идёт по массиву и сравнивает элемент с другими элементами из отсортированной части,
		то есть ищет нужное место для этого извлеченного элемента*/
		while ((j < n - 1) && (x > A[j + 1])) {
			A[j] = A[j + 1];
			j++;
		}
		A[j] = x; //присваивает элементу массива подходящее значение
	}
}

//бинарные вставки
void BinaryInsertion(int A[], int n) {
	int i, j, left, mid, right, x;
	/*также делит массив на 2 участка - отсортированный(слева) и неотсортированный(справа).
	Извлекает один элемент массива, затем находит середину отсортированного участка
	и сравнивает извлечённый элемент с серединой отсортированного участка.
	Далее, в зависимости от результата сравнения, либо двигается
	по отсортированному участку влево, либо оставляет этот элемент на том месте*/
	for (i = 1; i < n; i++) {
		x = A[i];
		left = 0; //левая граница отсортированного участка
		right = i; //правая граница отсортированного участка
		while (left < right) {
			mid = (left + right) / 2; //середина отсортированного участка
			if (A[mid] <= x) //сравнение
				left = mid + 1; //и, соответственно, рассматривает часть, которая правее середины
			else right = mid; //и, соответственно, рассматривает часть, которая левее середины
		}
		//поиск "своего" места в массиве
		for (j = i; j > right; j--) {
			A[j] = A[j - 1]; //смещает элементы массива вправо на 1
		}
		A[right] = x; //присваивает элементу массива подходящее значение
	}
}

//попарные вставки с поиском сразу двух элементов
void PairInsertionSort(int A[], int n) {
	/*В буфер отправляются не один, а сразу два рядом стоя́щих элемента.
	Сначала вставляется бОльший элемент из пары и сразу после него
	метод простой вставки применяется к меньшему элементу из пары.
	Поскольку второй меньше, место для него можно искать не во всей сортированной области, а
	начиная с места вставки предыдущего.
	В нашем случае бОльший элемент из пары будет обозначаться "y"*/
	int i, j, x, y;
	for (i = 0; i < n - 1; i += 2) {
		//заносит в буфер пару элементов массива
		if (A[i] < A[i + 1]) {
			x = A[i];
			y = A[i + 1]; //наибольший из двух
		}
		else {
			x = A[i + 1];
			y = A[i]; //наибольший из двух
		}
		//вставляет наибольший элемент из пары
		for (j = i - 1; j >= 0 && A[j] > y; j--) {
			A[j + 2] = A[j];
		}
		A[j + 2] = y; //присваивает элементу массива подходящее значение
		//запоминает место вставки наибольшего элемента
		int k = j;
		//вставляет наименьший элемент из пары
		for (j = k; j >= 0 && A[j] > x; j--) {
			A[j + 1] = A[j];
		}
		A[j + 1] = x; //присваивает элементу массива подходящее значение
	}
	/*на случай нечётного количества элементов в массиве для последнего из них
	применяется сортировка простыми вставками с поиском справа налево*/
	if (n % 2 == 1) {
		x = A[n - 1];
		for (i = n - 2; i >= 0 && A[i] > x; i--) {
			A[i + 1] = A[i];
		}
		A[i + 1] = x; //присваивает элементу массива подходящее значение
	}
}

//функция экспорта, которая передает адрес первого (нулевого по индексу) элемента массива
//и количество элементов в массиве
__declspec(dllexport) sort_info_t* GetSortList(int* count) {
	//массив структур информации по сортировкам 
	static sort_info_t sort_list[] = {
		{ LeftInsertion,SORT_INSERTION,SORT_QUADRATIC,"Left Insertion" },
		{ RightInsertion,SORT_INSERTION,SORT_QUADRATIC,"Right Insertion" },
		{ BinaryInsertion,SORT_INSERTION,SORT_QUADRATIC,"Binary Insertion" },
		{ PairInsertionSort,SORT_INSERTION,SORT_QUADRATIC,"Pair Insertion" }
	};
	*count = sizeof(sort_list) / sizeof(sort_info_t);
	return sort_list;
}